{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgJ;;;;;;;;;;;;;;;;;AC5D/G;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAuB;AACtC,UAAU,0BAA0B;AACpC,UAAU,gCAAgC;AAC1C,UAAU,iCAAiC;AAC3C,UAAU,+BAA+B;AACzC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,4BAA4B,6CAAe;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,6CAAe;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,6CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;;ACjHI;AACE;AACF;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA,4BAA4B,6CAAe;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,6CAAe;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,6CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,IAAI,iDAAmB;AACvB;AACA;AACA,IAAI,gDAAkB,gBAAgB,gDAAkB;AACxD;AACA;AACA;AACA;AACA,6BAA6B,gDAAkB;AAC/C;AACA;AACA;AACA,YAAY,4CAAc;AAC1B,YAAY,4CAAc;AAC1B;AACA,YAAY,oDAAsB;AAClC;AACA;AACA;AACA,YAAY,qDAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6CAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yCAAyC;AACnD,UAAU,iCAAiC;AAC3C,UAAU,uCAAuC;AACjD,UAAU,mCAAmC;AAC7C,UAAU,qCAAqC;AAC/C,UAAU;AACV;AACA,0BAA0B,UAAU;AACpC,oDAAoD,GAAG;AACvD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,yCAAW;AACnB;AACA,KAAK;AACL;AACgB;;;;;;;;;;;;;;;;;;;ACjJT;AACP,mBAAmB,IAAI,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM;AACjD;AACO;AACP;AACA;AACO;AACP;AACA;AACA,mBAAmB,UAAU,GAAG,UAAU,GAAG,UAAU;AACvD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC/BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACN+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oDAAoD,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,uCAAS;AACjB,KAAK;AACL;AACA;AACA,KAAK;AACL","sources":["webpack://web-audio-hw3/./src/audio.ts","webpack://web-audio-hw3/./src/canvas.ts","webpack://web-audio-hw3/./src/main.ts","webpack://web-audio-hw3/./src/utils.ts","webpack://web-audio-hw3/webpack/bootstrap","webpack://web-audio-hw3/webpack/runtime/define property getters","webpack://web-audio-hw3/webpack/runtime/hasOwnProperty shorthand","webpack://web-audio-hw3/webpack/runtime/make namespace object","webpack://web-audio-hw3/./src/loader.ts"],"sourcesContent":["// Web Audio context and audio nodes\nlet audioCtx;\nlet element;\nlet sourceNode;\nlet analyserNode;\nlet gainNode;\nlet bassNode;\nlet trebleNode;\nconst DEFAULTS = Object.freeze({\n    gain: 0.5,\n    numSamples: 256\n});\nlet audioData = new Uint8Array(DEFAULTS.numSamples / 2);\n// Set up the WebAudio graph\nfunction setupWebaudio(filePath) {\n    const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContextClass();\n    // Create audio element and load file\n    element = new Audio();\n    loadSoundFile(filePath);\n    // WebAudio routing\n    sourceNode = audioCtx.createMediaElementSource(element);\n    analyserNode = audioCtx.createAnalyser();\n    analyserNode.fftSize = DEFAULTS.numSamples;\n    gainNode = audioCtx.createGain();\n    gainNode.gain.value = DEFAULTS.gain;\n    bassNode = audioCtx.createBiquadFilter();\n    bassNode.type = \"lowshelf\";\n    bassNode.gain.value = DEFAULTS.gain;\n    trebleNode = audioCtx.createBiquadFilter();\n    trebleNode.type = \"highshelf\";\n    trebleNode.gain.value = DEFAULTS.gain;\n    // Connect nodes\n    sourceNode.connect(analyserNode);\n    analyserNode.connect(bassNode);\n    bassNode.connect(trebleNode);\n    trebleNode.connect(gainNode);\n    gainNode.connect(audioCtx.destination);\n}\n// Load a new sound file into the <audio> element\nfunction loadSoundFile(filePath) {\n    element.src = filePath;\n}\n// Control playback\nfunction playCurrentSound() {\n    element.play();\n}\nfunction pauseCurrentSound() {\n    element.pause();\n}\n// Volume & filter controls\nfunction setVolume(value) {\n    gainNode.gain.value = Number(value);\n}\nfunction setBassVolume(value) {\n    bassNode.gain.value = Number(value) * 10;\n}\nfunction setTrebleVolume(value) {\n    trebleNode.gain.value = Number(value) * 10;\n}\nexport { audioCtx, setupWebaudio, playCurrentSound, pauseCurrentSound, loadSoundFile, setVolume, setBassVolume, setTrebleVolume, analyserNode };\n","import * as utils from './utils';\nlet ctx;\nlet canvasWidth;\nlet canvasHeight;\nlet gradient;\nlet analyserNode;\nlet audioData;\nfunction setupCanvas(canvasElement, analyserNodeRef) {\n    ctx = canvasElement.getContext(\"2d\");\n    canvasWidth = canvasElement.width;\n    canvasHeight = canvasElement.height;\n    gradient = utils.getLinearGradient(ctx, 0, 0, 0, canvasHeight, [\n        { percent: 0, color: \"red\" },\n        { percent: 0.25, color: \"purple\" },\n        { percent: 0.5, color: \"darkblue\" },\n        { percent: 0.75, color: \"black\" },\n        { percent: 1, color: \"black\" }\n    ]);\n    analyserNode = analyserNodeRef;\n    audioData = new Uint8Array(analyserNode.fftSize / 2);\n}\nfunction draw(params, spriteParams1, spriteParams2) {\n    if (params.showFrequency) {\n        analyserNode.getByteFrequencyData(audioData);\n    }\n    else {\n        analyserNode.getByteTimeDomainData(audioData);\n    }\n    ctx.save();\n    ctx.fillStyle = \"black\";\n    ctx.globalAlpha = 0.1;\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n    ctx.restore();\n    if (params.showGradient) {\n        ctx.save();\n        ctx.fillStyle = gradient;\n        ctx.globalAlpha = 0.3;\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n        ctx.restore();\n    }\n    if (params.showBars) {\n        const barSpacing = 4;\n        const margin = 5;\n        const screenWidthForBars = canvasWidth - (audioData.length * barSpacing) - margin * 2;\n        const barWidth = screenWidthForBars / audioData.length;\n        const barHeight = 200;\n        const topSpacing = 100;\n        ctx.save();\n        ctx.fillStyle = 'rgba(255,255,255,0.50)';\n        ctx.strokeStyle = 'rgba(0,0,0,0.50)';\n        for (let i = 0; i < audioData.length; i++) {\n            const x = margin + i * (barWidth + barSpacing);\n            const y = topSpacing + 256 - audioData[i];\n            ctx.fillRect(x, y, barWidth, barHeight);\n            ctx.strokeRect(x, y, barWidth, barHeight);\n        }\n        ctx.restore();\n    }\n    if (params.showCircles) {\n        const maxRadius = canvasHeight / 4;\n        ctx.save();\n        ctx.globalAlpha = 0.5;\n        for (let i = 0; i < audioData.length; i++) {\n            const percent = audioData[i] / 255;\n            const circleRadius = percent * maxRadius;\n            ctx.beginPath();\n            ctx.fillStyle = utils.makeColor(255, 0, 180, 0.34 - percent / 3.0);\n            ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.closePath();\n            ctx.beginPath();\n            ctx.fillStyle = utils.makeColor(0, 0, 200, 0.10 - percent / 10.0);\n            ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius * 1.5, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.closePath();\n            ctx.beginPath();\n            ctx.fillStyle = utils.makeColor(200, 0, 0, 0.5 - percent / 5.0);\n            ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius * 0.5, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    spriteParams1.update(audioData);\n    spriteParams1.draw(ctx, canvasHeight, audioData);\n    spriteParams2.update(audioData);\n    spriteParams2.draw(ctx, canvasHeight, audioData);\n    const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n    const data = imageData.data;\n    const length = data.length;\n    const width = imageData.width;\n    for (let i = 0; i < length; i += 4) {\n        if (params.showNoise && Math.random() < 0.02) {\n            data[i] = data[i + 1] = data[i + 2] = 180;\n        }\n        if (params.showInvert) {\n            const red = data[i];\n            const green = data[i + 1];\n            const blue = data[i + 2];\n            data[i] = 255 - red;\n            data[i + 1] = 255 - green;\n            data[i + 2] = 255 - blue;\n        }\n    }\n    if (params.showEmboss) {\n        for (let i = 0; i < length; i++) {\n            if (i % 4 === 3)\n                continue;\n            data[i] = 127 + 2 * data[i] - data[i + 4] - data[i + width * 4];\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n}\nexport { setupCanvas, draw };\n","import * as audio from './audio';\nimport * as canvas from './canvas';\nimport * as utils from './utils';\nconst drawParams = {\n    showGradient: true,\n    showBars: true,\n    showCircles: true,\n    showNoise: false,\n    showInvert: false,\n    showEmboss: false,\n    showFrequency: true,\n    showWave: false\n};\nclass Sprite {\n    constructor(x, y, innerColorR, innerColorG, innerColorB, outerColorR, outerColorG, outerColorB) {\n        this.x = x;\n        this.y = y;\n        this.innerColorR = innerColorR;\n        this.innerColorG = innerColorG;\n        this.innerColorB = innerColorB;\n        this.outerColorR = outerColorR;\n        this.outerColorG = outerColorG;\n        this.outerColorB = outerColorB;\n    }\n    update(audioData) {\n        this.audioData = audioData;\n    }\n    draw(ctx, canvasHeight, audioData) {\n        const maxRadius = canvasHeight / 2;\n        ctx.save();\n        ctx.globalAlpha = 0.5;\n        for (let i = 0; i < this.audioData.length; i++) {\n            const percent = this.audioData[i] / 255;\n            const circleRadius = percent * maxRadius;\n            ctx.beginPath();\n            ctx.fillStyle = utils.makeColor(this.innerColorR, this.innerColorG, this.innerColorB, 0.34 - percent / 3.0);\n            ctx.arc(this.x, this.y, circleRadius, 0, 2 * Math.PI, false);\n            ctx.fill();\n            ctx.closePath();\n            ctx.beginPath();\n            ctx.fillStyle = utils.makeColor(this.outerColorR, this.outerColorG, this.outerColorB, 0.34 - percent / 3.0);\n            ctx.arc(this.x, this.y, circleRadius * 1.5, 0, 2 * Math.PI, false);\n            ctx.fill();\n            ctx.closePath();\n            ctx.beginPath();\n            ctx.fillStyle = utils.makeColor(255, 255, 0, 0.5 - percent / 5.0);\n            ctx.arc(this.x, this.y, circleRadius * 0.5, 0, 2 * Math.PI, false);\n            ctx.fill();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n}\nlet spriteParams1;\nlet spriteParams2;\nconst DEFAULTS = Object.freeze({\n    sound1: \"media/Neon-Cheese-Irritation.mp3\"\n});\nfunction init(audioFiles, spriteData1, spriteData2) {\n    spriteParams1 = new Sprite(spriteData1.x, spriteData1.y, spriteData1.innerColorR, spriteData1.innerColorG, spriteData1.innerColorB, spriteData1.outerColorR, spriteData1.outerColorG, spriteData1.outerColorB);\n    spriteParams2 = new Sprite(spriteData2.x, spriteData2.y, spriteData2.innerColorR, spriteData2.innerColorG, spriteData2.innerColorB, spriteData2.outerColorR, spriteData2.outerColorG, spriteData2.outerColorB);\n    audio.setupWebaudio(DEFAULTS.sound1);\n    const canvasElement = document.querySelector(\"canvas\");\n    setupUI(canvasElement);\n    canvas.setupCanvas(canvasElement, audio.analyserNode);\n    loop();\n}\nfunction setupUI(canvasElement) {\n    const fsButton = document.querySelector(\"#btn-fs\");\n    fsButton.onclick = () => utils.goFullscreen(canvasElement);\n    const playButton = document.querySelector(\"#btn-play\");\n    playButton.onclick = (e) => {\n        const target = e.target;\n        if (audio.audioCtx.state === \"suspended\")\n            audio.audioCtx.resume();\n        if (target.dataset.playing === \"no\") {\n            audio.playCurrentSound();\n            target.dataset.playing = \"yes\";\n        }\n        else {\n            audio.pauseCurrentSound();\n            target.dataset.playing = \"no\";\n        }\n    };\n    const volumeSlider = document.querySelector(\"#slider-volume\");\n    const volumeLabel = document.querySelector(\"#volumeLabel\");\n    volumeSlider.oninput = e => {\n        const target = e.target;\n        audio.setVolume(target.value);\n        volumeLabel.innerHTML = Math.round((+target.value / 2) * 100).toString();\n    };\n    volumeSlider.dispatchEvent(new Event(\"input\"));\n    const trebleSlider = document.querySelector(\"#slider-treble\");\n    const trebleLabel = document.querySelector(\"#trebleLabel\");\n    trebleSlider.oninput = e => {\n        const target = e.target;\n        audio.setTrebleVolume(target.value);\n        trebleLabel.innerHTML = Math.round((+target.value / 2) * 100).toString();\n    };\n    trebleSlider.dispatchEvent(new Event(\"input\"));\n    const bassSlider = document.querySelector(\"#slider-bass\");\n    const bassLabel = document.querySelector(\"#bassLabel\");\n    bassSlider.oninput = e => {\n        const target = e.target;\n        audio.setBassVolume(target.value);\n        bassLabel.innerHTML = Math.round((+target.value / 2) * 100).toString();\n    };\n    bassSlider.dispatchEvent(new Event(\"input\"));\n    const trackSelect = document.querySelector(\"#trackSelect\");\n    trackSelect.onchange = e => {\n        const target = e.target;\n        audio.loadSoundFile(target.value);\n        if (playButton.dataset.playing === \"yes\") {\n            playButton.dispatchEvent(new MouseEvent(\"click\"));\n        }\n    };\n    const typeSelect = document.querySelector(\"#typeSelect\");\n    typeSelect.onclick = () => {\n        drawParams.showFrequency = typeSelect.selectedIndex === 0;\n        drawParams.showWave = typeSelect.selectedIndex === 1;\n    };\n    const checkboxes = [\n        { id: \"cb-gradient\", prop: \"showGradient\" },\n        { id: \"cb-bars\", prop: \"showBars\" },\n        { id: \"cb-circles\", prop: \"showCircles\" },\n        { id: \"cb-noise\", prop: \"showNoise\" },\n        { id: \"cb-invert\", prop: \"showInvert\" },\n        { id: \"cb-emboss\", prop: \"showEmboss\" }\n    ];\n    checkboxes.forEach(({ id, prop }) => {\n        const checkbox = document.querySelector(`#${id}`);\n        checkbox.checked = drawParams[prop];\n        checkbox.addEventListener(\"change\", () => {\n            drawParams[prop] = checkbox.checked;\n        });\n    });\n}\nfunction loop() {\n    const frameRate = 60;\n    const interval = 1000 / frameRate;\n    setTimeout(() => {\n        canvas.draw(drawParams, spriteParams1, spriteParams2);\n        loop();\n    }, interval);\n}\nexport { init };\n","export const makeColor = (red, green, blue, alpha = 1) => {\n    return `rgba(${red},${green},${blue},${alpha})`;\n};\nexport const getRandom = (min, max) => {\n    return Math.random() * (max - min) + min;\n};\nexport const getRandomColor = () => {\n    const floor = 35;\n    const getByte = () => getRandom(floor, 255 - floor);\n    return `rgba(${getByte()},${getByte()},${getByte()},1)`;\n};\nexport const getLinearGradient = (ctx, startX, startY, endX, endY, colorStops) => {\n    const lg = ctx.createLinearGradient(startX, startY, endX, endY);\n    for (const stop of colorStops) {\n        lg.addColorStop(stop.percent, stop.color);\n    }\n    return lg;\n};\nexport const goFullscreen = (element) => {\n    if (element.requestFullscreen) {\n        element.requestFullscreen();\n    }\n    else if (element.mozRequestFullscreen) {\n        element.mozRequestFullscreen();\n    }\n    else if (element.mozRequestFullScreen) {\n        element.mozRequestFullScreen();\n    }\n    else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen();\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as main from './main';\n// Wait for DOM to load before starting\nwindow.onload = () => {\n    console.log(\"window.onload called\");\n    // Fetch JSON config data\n    fetch('data/av-data.json')\n        .then(response => {\n        if (!response.ok) {\n            throw new Error('Failed to load JSON data');\n        }\n        return response.json();\n    })\n        .then((appData) => {\n        console.log(\"JSON data loaded:\", appData);\n        // Preload audio files\n        const audioFiles = appData.audioFiles.map(audio => {\n            const audioElement = new Audio(`media/${audio.fileName}`);\n            audioElement.preload = 'auto';\n            return {\n                ...audio,\n                src: audioElement.src\n            };\n        });\n        const spriteData1 = appData.spriteData1;\n        const spriteData2 = appData.spriteData2;\n        console.log(\"Preloading completed:\", audioFiles);\n        console.log(\"Sprite data loaded:\", spriteData1, spriteData2);\n        // Populate track dropdown\n        const trackSelect = document.querySelector(\"#trackSelect\");\n        appData.audioFiles.forEach(audio => {\n            const option = document.createElement('option');\n            option.value = `media/${audio.fileName}`;\n            option.textContent = audio.trackName;\n            if (audio.fileName === \"perfect-fart.mp3\") {\n                option.selected = true;\n            }\n            trackSelect.appendChild(option);\n        });\n        // Start main app\n        main.init(audioFiles, spriteData1, spriteData2);\n    })\n        .catch(error => {\n        console.error(\"Error loading JSON data:\", error);\n    });\n};\n"],"names":[],"sourceRoot":""}